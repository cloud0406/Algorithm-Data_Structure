# Big O Notation

여러가지 코드를 일반적으로 서로 비교하고 성능을 평가하는 방법.

- 한 문제에 대한 여러가지 해결책을 비교하고 성능이 어떤지 이해하는데 도움.
- 여러 접근법의 장단점을 얘기할때 유용 -> ex) 시간은 더 오래 걸려도 처리하는 시간에 변동이 없다던지 / 모든 접근법에는 장단점이 있기 때문에 반드시 하나의 접근법만이 최고의 방법은 아닐 수 있다.
- 빅오를 이해하면 디버그시 어디서 문제가 나타나며 어떤 부분이 비효율적인 코드인지 찾는데 도움이 된다.

## 좋은 코드란 무엇일까?

- 빠른 코드?
- 메모리를 덜 쓰는 코드?
- 더 읽기 쉬운 코드?

코드를 비교할때 단순히 걸리는 시간을 통해 비교하는 방법은 좋은 방법이라 할 수 없음

- 다른 기계라면 다른 시간이 나옴
- 같은 기계예도 반복해보면 결과가 다르게 기록될 수 있음

따라서 코드가 실행될때 걸리는 정확한 시간을 초로 측정하는것보다는 컴퓨터가 처리해야하는 연산 갯수를 세는 것이 정확 (어떤 컴퓨터를 사용하든 연산 개수는 동일하기 때문에)

같은 연산을 하는 두개의 코드 비교

```js
function addUpToFirst(n) {
  var toatl = 0;
  for (var i = 0; i <= n; i++) {
    total += i;
  }
  return total;
  ㄴ;
}
```

n에 크기에 따라 반복문의 반복 횟수가 달라지기 때문에 n이 10억처럼 매우 커질경우 그만큼 오래걸림

아래 코드를 보자

```js
function addUpToSecond(n) {
  return (n * (n + 1)) / 2;
}
```

같은 연산을 하지만 n에 크기에 상관없이 연산을 동일하게 3번함 (\*, +, /)
n이 커질수록 첫 번째 코드보다 두 번째 코드가 연산 횟수가 현저히 적음을 확인할 수 있음.

위의 두 함수를 빅오로 표현하면 다음과 같음
첫 번째 함수인 addUpToFirst는 O(1) -> 어떠한 입력값 n이 들어와도 n에 상관없이 연산 수가 동일
두 번째 함수인 addUpToSecond는 O(n) -> 입력값 n에 따라 반복 횟수가 선형적으로 증가

```js
function countUpAndDown(n) {
  console.log("Going UP!");
  for (let i = 0; i < n; i++) {
    console.log(i);
  }

  console.log("At the top! Going Down...");
  for (let j = n - 1; j >= 0; j--) {
    console.log(j);
  }
}
```

위의 함수는 같은 작업을 거꾸로하는 두 반복문이 있음. 그렇기 때문에 O(2n)이라 생각할 수 있지만 큰 틀에서만 생각하면 O(n)임.

```js
function printAllPairs(n) {
  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      console.log(i, j);
    }
  }
}
```

위의 함수도 마찬가지로 n이 커질수록 시간이 증가되지만 반복문이 2개여서 O(2n)으로 표현하는 것이 아니라 중첩되어 있기 때문에 O(n\*n) -> 즉, O(n제곱)이 된다. 이 경우에는 n이 커질수록 실행 시간이 n제곱의 값으로 늘어나게 된다.

위의 예시들에서부터 빅오란 기본적으로 입력인 n이 커질수록 알고리즘이 얼마나 효율적으로 표현하는 방식이라는 것을 기억하자.
